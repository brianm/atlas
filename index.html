<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
/*<![CDATA[*/
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
/*]]>*/
  </style>
  <link rel="stylesheet" href="pandoc.css" />
</head>
<body>
<nav id="TOC">
<h1>Atlas</h1>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#where-to-get-it">Where to get it</a></li>
<li><a href="#minute-quick-start">5 minute quick start</a></li>
<li><a href="#building">Building</a></li>
<li><a href="#configuration">Configuration</a><ul>
<li><a href="#environment-specification">Environment specification</a><ul>
<li><a href="#reading-configuration-values-from-a-file">Reading configuration values from a file</a></li>
<li><a href="#base-element">Base element</a></li>
<li><a href="#provisioners">Provisioners</a><ul>
<li><a href="#com.ning.atlas.aws.ec2provisioner">com.ning.atlas.aws.EC2Provisioner</a></li>
<li><a href="#com.ning.atlas.aws.rdsprovisioner">com.ning.atlas.aws.RDSProvisioner</a></li>
<li><a href="#com.ning.atlas.virtualbox.vboxprovisioner">com.ning.atlas.virtualbox.VBoxProvisioner</a></li>
<li><a href="#com.ning.atlas.statictaggedserverprovisioner">com.ning.atlas.StaticTaggedServerProvisioner</a></li>
</ul></li>
<li><a href="#initializers">Initializers</a><ul>
<li><a href="#com.ning.atlas.atlasinitializer">com.ning.atlas.AtlasInitializer</a></li>
<li><a href="#com.ning.atlas.galaxy.microgalaxyinitializer">com.ning.atlas.galaxy.MicroGalaxyInitializer</a></li>
<li><a href="#com.ning.atlas.chef.ubuntuchefsoloinitializer">com.ning.atlas.chef.UbuntuChefSoloInitializer</a></li>
</ul></li>
<li><a href="#installers">Installers</a><ul>
<li><a href="#com.ning.atlas.galaxy.microgalaxyinstaller">com.ning.atlas.galaxy.MicroGalaxyInstaller</a></li>
<li><a href="#com.ning.atlas.galaxy.galaxyinstaller">com.ning.atlas.galaxy.GalaxyInstaller</a></li>
<li><a href="#com.ning.atlas.oracle.oracleloaderinstaller">com.ning.atlas.oracle.OracleLoaderInstaller</a></li>
<li><a href="#com.ning.atlas.aws.elbinstaller">com.ning.atlas.aws.ELBInstaller</a></li>
</ul></li>
</ul></li>
<li><a href="#system-specification">System specification</a></li>
</ul></li>
<li><a href="#running">Running</a></li>
<li><a href="#output">Output</a></li>
<li><a href="#resources">Resources</a><ul>
<li><a href="#virtualbox">VirtualBox</a></li>
<li><a href="#getting-help">Getting Help</a></li>
</ul></li>
</ul>
</nav>
<h1 id="introduction"><a href="#TOC">Introduction</a></h1>
<p>Atlas is a tool to automatically spin up complete environments consisting of multiple machines and software installed on them. These environments are described via configuration files which are fed to Atlas, and Atlas then automatically procures the necessary resources and installs the base machines and the software running on them.</p>
<p>Atlas is currently able to spin up environments on EC2 and VirtualBox.</p>
<p>Atlas is being built by various folks, mostly from <a href="http://www.ning.com">Ning</a>, and is made available under the <a href="http://www.apache.org/licenses/LICENSE-2.0.txt">Apache License, 2.0</a>.</p>
<h1 id="where-to-get-it"><a href="#TOC">Where to get it</a></h1>
<p>Atlas is on github: <a href="https://github.com/ning/atlas">https://github.com/ning/atlas</a>.</p>
<h1 id="minute-quick-start"><a href="#TOC">5 minute quick start</a></h1>
<p>Build it:</p>
<pre><code>rake package
</code></pre>
<p>Create the <a href="#environment-specification">environment specification</a> and <a href="#system-specification">system specification</a>.</p>
<p>Provision stuff:</p>
<pre><code>./target/atlas -e &lt;environment specification file&gt; -s &lt;system specification file&gt; provision
</code></pre>
<p>Initialize stuff:</p>
<pre><code>./target/atlas -e &lt;environment specification file&gt; -s &lt;system specification file&gt; initialize
</code></pre>
<p>Start stuff:</p>
<pre><code>./target/atlas -e &lt;environment specification file&gt; -s &lt;system specification file&gt; start
</code></pre>
<h1 id="building"><a href="#TOC">Building</a></h1>
<p>The easiest way to build atlas, is to use <a href="http://rake.rubyforge.org/">rake</a> which usually comes with any decent ruby installation:</p>
<pre><code>rake package
</code></pre>
<p>This will invoke Maven and generate an executable <code>atlas</code> file.</p>
<p>You can also do this manually:</p>
<pre><code>mvn install
cat target/atlas-*.jar &gt;&gt; target/atlas
chmod +x target/atlas
</code></pre>
<h1 id="configuration"><a href="#TOC">Configuration</a></h1>
<p>Atlas distinguishes between environment and system when it comes to configuration.</p>
<p>The environment configuration specifies the &quot;how&quot;: how to provision machines, how to deploy services onto those machines, and so forth.</p>
<p>The system configuration specifies the &quot;what&quot;: which services are defined, how many of each service should be deployed, etc.</p>
<p>Both files are basically ruby files that get executed. The configuration is specified in a DSL that gets executed as normal ruby code. Thus, you can basically do whatever you want in these files as long as you can express it in ruby.</p>
<h2 id="environment-specification"><a href="#TOC">Environment specification</a></h2>
<p>An environment specification file typically has this structure:</p>
<pre class="sourceCode"><code class="sourceCode ruby"><span class="co"># require statements etc.</span><br /><span class="co"># constants</span><br /><span class="co"># first environment definition</span><br /><span class="co">#   provisioner declarations</span><br /><span class="co">#   initializer declarations</span><br /><span class="co">#   installer declarations</span><br /><span class="co">#   base declarations</span><br /><span class="co"># additional environment definitions as necessary</span></code></pre>
<p>A simple environment configuration for EC2 might look like this:</p>
<pre class="sourceCode"><code class="sourceCode ruby"><span class="co"># EC2 access configuration, could also be read from a file</span><br />ec2_access_key = <span class="st">&quot;...&quot;</span> <span class="co"># EC2 access key</span><br />ec2_secret_key = <span class="st">&quot;...&quot;</span> <span class="co"># EC2 secret key</span><br />ec2_keypair_id = <span class="st">&quot;...&quot;</span> <span class="co"># name of the .pem file used for ssh'ing into the EC2 machines</span><br />s3_access_key  = <span class="st">&quot;...&quot;</span> <span class="co"># S3 access key</span><br />s3_secret_key  = <span class="st">&quot;...&quot;</span> <span class="co"># S3 secret key</span><br /><br />environment <span class="st">&quot;ec2&quot;</span> <span class="kw">do</span><br />  set <span class="st">&quot;xn.base-domain&quot;</span> =&gt; <span class="st">&quot;echo.xn.io&quot;</span><br /><br />  set <span class="st">&quot;aws.shared.access_key&quot;</span> =&gt; s3_access_key,<br />      <span class="st">&quot;aws.shared.secret_key&quot;</span> =&gt; s3_secret_key<br /><br />  provisioner com.ning.atlas.aws.<span class="dt">EC2Provisioner</span>, {<br />    <span class="st">:access_key</span> =&gt; ec2_access_key,<br />    <span class="st">:secret_key</span> =&gt; ec2_secret_key,<br />    <span class="st">:keypair_id</span> =&gt; ec2_keypair_id<br />  }<br /><br />  initializer <span class="st">&quot;atlas&quot;</span>, com.ning.atlas.<span class="dt">AtlasInitializer</span>, {<br />    <span class="st">:ssh_user</span>     =&gt; <span class="st">&quot;ubuntu&quot;</span>,<br />    <span class="st">:ssh_key_file</span> =&gt; <span class="st">&quot;</span><span class="ot">#{</span><span class="dt">ENV</span>[<span class="st">'HOME'</span>]<span class="ot">}</span><span class="st">/.ec2/</span><span class="ot">#{</span>ec2_keypair_id<span class="ot">}</span><span class="st">.pem&quot;</span><br />  }<br /><br />  initializer <span class="st">&quot;chef&quot;</span>, com.ning.atlas.chef.<span class="dt">UbuntuChefSoloInitializer</span>, {<br />    <span class="st">:ssh_user</span>     =&gt; <span class="st">&quot;ubuntu&quot;</span>,<br />    <span class="st">:ssh_key_file</span> =&gt; <span class="st">&quot;</span><span class="ot">#{</span><span class="dt">ENV</span>[<span class="st">'HOME'</span>]<span class="ot">}</span><span class="st">/.ec2/</span><span class="ot">#{</span>ec2_keypair_id<span class="ot">}</span><span class="st">.pem&quot;</span>,<br />    <span class="st">:recipe_url</span>   =&gt; <span class="st">&quot;s3://my-atlas-resources/chef-solo.tar.gz&quot;</span>,<br />    <span class="st">:s3_access_key</span> =&gt; s3_access_key,<br />    <span class="st">:s3_secret_key</span> =&gt; s3_secret_key<br />  }<br /><br />  installer <span class="st">&quot;ugx&quot;</span>, com.ning.atlas.galaxy.<span class="dt">MicroGalaxyInstaller</span>, {<br />    <span class="st">:ssh_user</span>     =&gt; <span class="st">&quot;ubuntu&quot;</span>,<br />    <span class="st">:ssh_key_file</span> =&gt; <span class="st">&quot;</span><span class="ot">#{</span><span class="dt">ENV</span>[<span class="st">'HOME'</span>]<span class="ot">}</span><span class="st">/.ec2/</span><span class="ot">#{</span>ec2_keypair_id<span class="ot">}</span><span class="st">.pem&quot;</span>,<br />    <span class="st">:ugx_user</span>     =&gt; <span class="st">&quot;user&quot;</span><br />  }<br /><br />  base <span class="st">&quot;ruby-server&quot;</span>, <span class="st">:ami</span> =&gt; <span class="st">&quot;ami-e2af508b&quot;</span>, <span class="st">:init</span> =&gt; [<span class="st">'atlas'</span>, <span class="st">'chef:role[ruby_server]'</span>]<br />  base <span class="st">&quot;shell&quot;</span>,       <span class="st">:ami</span> =&gt; <span class="st">&quot;ami-e2af508b&quot;</span>, <span class="st">:init</span> =&gt; [<span class="st">'atlas'</span>, <span class="st">'chef:role[shell]'</span>]<br /><span class="kw">end</span></code></pre>
<p>This configuration defines one ec2 provisioner, two initializers and one installer, and it declares two bases that then can be used in the system configuration.</p>
<p>Environments can be nested. The inner environment will inherit all definitions from the outer environment, but not the other way around. This is mostly useful for providing provisioner scoping for <a href="#base-element">base elements</a> as they automatically use the provisioner defined in the environment, and there can only be one provisioner per environment. For instance, for an EC2 environment with an RDS database, you'd use a structure like:</p>
<pre class="sourceCode"><code class="sourceCode ruby">environment <span class="st">&quot;ec2&quot;</span> <span class="kw">do</span><br />  ...<br />  environment <span class="st">&quot;rds-databases&quot;</span> <span class="kw">do</span><br />  ...<br />  <span class="kw">end</span><br /><span class="kw">end</span></code></pre>
<h3 id="reading-configuration-values-from-a-file"><a href="#TOC">Reading configuration values from a file</a></h3>
<p>Atlas comes with a helper class to read e.g. EC2 keys and related info from a file. If you put this at the top of your environment configuration:</p>
<pre class="sourceCode"><code class="sourceCode ruby">require <span class="st">'atlas/tools/rc'</span><br /><br />rc = <span class="dt">Atlas</span>::<span class="dt">Tools</span>::<span class="dt">RC</span>.read_rc[<span class="st">'aws'</span>]</code></pre>
<p>then that will read from a file <code>$HOME/.atlasrc</code> by default, which is assumed to be a YAML file with this structure:</p>
<pre class="sourceCode"><code class="sourceCode ruby">aws:<br />   secret_key: &lt;<span class="dt">EC2</span> secret key&gt;<br />   access_key: &lt;<span class="dt">EC2</span> access key&gt;<br />   keypair_id: &lt;name of the ssh key&gt;</code></pre>
<p>The configuration values can then be used like this in the environment configuration file:</p>
<pre class="sourceCode"><code class="sourceCode ruby">provisioner com.ning.atlas.aws.<span class="dt">EC2Provisioner</span>, {<br />  <span class="st">:access_key</span> =&gt; rc[<span class="st">'access_key'</span>],<br />  <span class="st">:secret_key</span> =&gt; rc[<span class="st">'secret_key'</span>],<br />  <span class="st">:keypair_id</span> =&gt; rc[<span class="st">'keypair_id'</span>]<br />}</code></pre>
<h3 id="base-element"><a href="#TOC">Base element</a></h3>
<p>The base element defines blueprints for servers which is provisioned and initialized. The system configuration contains the corresponding server elements which 'instantiates' the base element blueprint and deploys services via installers.</p>
<p>The base element consists of a set of attributes to be used by the provisioners and initializers described further below, plus the optional special attribute <code>init</code> that defines any initializers to use for for the blueprint.</p>
<p>The base element will automatically use the provisioner defined in the environment in which the base element is defined. It is up to provisioners to determine if they should run or not. For instance, the EC2 provisioner checks for the presence of the <code>ami</code> attribute. If it is defined, then it will run when a server is created using the base element.</p>
<p>Examples:</p>
<pre class="sourceCode"><code class="sourceCode ruby">base <span class="st">&quot;ruby-server&quot;</span>, {<br />  <span class="st">:ami</span> =&gt; <span class="st">&quot;ami-e2af508b&quot;</span>,<br />  <span class="st">:instance_type</span> =&gt; <span class="st">&quot;m1.large&quot;</span><br />}</code></pre>
<p>This defines a blue print called <code>ruby-server</code> for an EC2 instance using the AMI <code>ami-e2af508b</code> on an <code>m1.large</code> instance. Both of these attributes are used by the EC2 provisioner described <a href="com.ning.atlas.aws.EC2Provisioner">below</a>.</p>
<pre class="sourceCode"><code class="sourceCode ruby">base <span class="st">&quot;ruby-server&quot;</span>, {<br />  <span class="st">:ami</span> =&gt; <span class="st">&quot;ami-e2af508b&quot;</span>,<br />  <span class="st">:init</span> =&gt; [<span class="st">'atlas'</span>, <span class="st">'chef:role[ruby_server]'</span>]<br />}</code></pre>
<p>This is a variation of the above that doesn't specify the instance type for the EC2 provisioner (which then will use the default value), and instead it specifies two initializers, <code>atlas</code> and <code>chef</code>.</p>
<h3 id="provisioners"><a href="#TOC">Provisioners</a></h3>
<p>A provisioner is responsible for provisioning bare machines/instances. Atlas currently has these provisioners:</p>
<ul>
<li><code>com.ning.atlas.aws.EC2Provisioner</code> for provisioning on Amazon EC2</li>
<li><code>com.ning.atlas.aws.RDSProvisioner</code> for provisioning on Amazon RDS</li>
<li><code>com.ning.atlas.virtualbox.VBoxProvisioner</code> for provisioning VirtualBox instances.</li>
<li><code>com.ning.atlas.StaticTaggedServerProvisioner</code> for incorporating already provisioned machines.</li>
</ul>
<p>A given environment can have only one provisioner defined which will then automatically be used by all base elements defined in that environment.</p>
<h5 id="com.ning.atlas.aws.ec2provisioner"><a href="#TOC">com.ning.atlas.aws.EC2Provisioner</a></h5>
<p>The <code>EC2Provisioner</code> brings up EC2 instances. It needs to be provided with three environment configuration options (see <a href="http://alestic.com/2009/11/ec2-credentials">this post</a> for an explanation of what these mean):</p>
<ul>
<li><code>access_key</code>: The EC2 access key.</li>
<li><code>secret_key</code>: The EC2 secret key.</li>
<li><code>keypair_id</code>: The name of the private key <code>.pem</code> file which is used to ssh to EC2 machines, without the <code>.pem</code> file extension.</li>
</ul>
<p>It makes use of two additional properties defined in the <a href="#base-element">base element</a>:</p>
<ul>
<li><code>ami</code>: The AMI identifier, e.g. <code>ami-e2af508b</code>.</li>
<li><code>instance_type</code>: The <a href="http://aws.amazon.com/ec2/instance-types/">type of the instance</a>, e.g. <code>m1.large</code>. Note that the AMI has to support the instance type.</li>
</ul>
<p>Example:</p>
<pre class="sourceCode"><code class="sourceCode ruby">provisioner com.ning.atlas.aws.<span class="dt">EC2Provisioner</span>, {<br />  <span class="st">:access_key</span> =&gt; ec2_access_key,<br />  <span class="st">:secret_key</span> =&gt; ec2_secret_key,<br />  <span class="st">:keypair_id</span> =&gt; ec2_keypair_id<br />}<br /><br />base <span class="st">&quot;ruby-server&quot;</span>, {<br />  <span class="st">:ami</span> =&gt; <span class="st">&quot;ami-e2af508b&quot;</span>,<br />  <span class="st">:instance_type</span> =&gt; <span class="st">&quot;m1.large&quot;</span><br />}</code></pre>
<h5 id="com.ning.atlas.aws.rdsprovisioner"><a href="#TOC">com.ning.atlas.aws.RDSProvisioner</a></h5>
<p>The <code>RDSProvisioner</code> provisions <a href="http://aws.amazon.com/rds/">Amazon RDS</a> databases. For details about RDS see the <a href="http://docs.amazonwebservices.com/AmazonRDS/latest/GettingStartedGuide/">Getting Started Guide</a>. The provisioner needs these environment configuration options:</p>
<ul>
<li><code>access_key</code>: The EC2 access key.</li>
<li><code>secret_key</code>: The EC2 secret key.</li>
</ul>
<p>In addition, it makes use of these <a href="#base-element">base element</a> properties:</p>
<ul>
<li><code>license_model</code>: The license model for the database instance. One of <code>license-included</code>, <code>bring-your-own-license</code>, <code>general-public-license</code>. Default is <code>general-public-license</code>. For MySQL, this is the only valid option.</li>
<li><code>storage_size</code>: The amount of storage (in gigabytes) to be initially allocated for the database instance. Must be an integer from 5 to 1024.</li>
<li><code>instance_class</code>: The compute and memory capacity of the database instance. One of <code>db.m1.small</code>, <code>db.m1.large</code>, <code>db.m1.xlarge</code>, <code>db.m2.xlarge</code>, <code>db.m2.2xlarge</code>, <code>db.m2.4xlarge</code>.</li>
<li><code>engine</code>: The name of the database engine to be used for this instance. Valid values are <code>MySQL</code>, <code>oracle-se1</code>, <code>oracle-se</code>, <code>oracle-ee</code>.</li>
<li><code>username</code>: The name of master user for the client database instance. Must be 1 to 16 alphanumeric characters, and the first character must be a letter. Cannot be a reserved word for the chosen database engine.</li>
<li><code>password</code>: The password for the master database instance user. Must contain 4 to 41 alphanumeric characters.</li>
</ul>
<pre class="sourceCode"><code class="sourceCode ruby">provisioner com.ning.atlas.aws.<span class="dt">RDSProvisioner</span>, {<br />  <span class="st">:access_key</span> =&gt; ec2_access_key,<br />  <span class="st">:secret_key</span> =&gt; ec2_secret_key<br />}<br /><br />base <span class="st">&quot;oracle&quot;</span>, {<br />  <span class="st">:storage_size</span> =&gt; <span class="dv">10</span>,<br />  <span class="st">:instance_class</span> =&gt; <span class="st">&quot;db.m1.small&quot;</span>,<br />  <span class="st">:engine</span> =&gt; <span class="st">&quot;oracle-se1&quot;</span>,<br />  <span class="st">:username</span> =&gt; <span class="st">&quot;user&quot;</span>,<br />  <span class="st">:password</span> =&gt; <span class="st">&quot;password&quot;</span>,<br />  <span class="st">:license_model</span> =&gt; <span class="st">&quot;bring-your-own-license&quot;</span><br />}</code></pre>
<h5 id="com.ning.atlas.virtualbox.vboxprovisioner"><a href="#TOC">com.ning.atlas.virtualbox.VBoxProvisioner</a></h5>
<p>The <code>VBoxProvisioner</code> provisions <a href="http://www.virtualbox.org/">VirtualBox</a> instances. For more information about VirtualBox see the <a href="http://www.virtualbox.org/manual/UserManual.html">VirtualBox user documentation</a>.</p>
<p>For this provisioner to work, Oracle VirtualBox 4.1.0 or newer is required. The VirtualBox image must also contain the <a href="http://www.virtualbox.org/manual/ch04.html">Guest Additions</a> for Atlas to work correctly. It is important to note that the <code>virtualbox-ose-guest-utils</code> Debian package will not work for this. Instead, use the correct version of the VBoxGuestAdditions ISO provided from the <a href="http://download.virtualbox.org/virtualbox/">official site</a>.</p>
<p>The provisioner needs these environment configuration options:</p>
<ul>
<li><code>pub_key_file</code>: The file path to the public key to allow password-less SSH login into the instances.</li>
<li><code>intnet_name</code>: The name of the internal network that VirtualBox will use.</li>
<li><code>bridgedif_name</code>: The name of the host interface the given virtual network interface will use.</li>
</ul>
<p>You can find the appropriate values by running the following command in terminal:</p>
<pre><code>$ VBoxManage list bridgedifs
</code></pre>
<p>It makes use of these additional properties defined in the <a href="#base-element">base element</a>:</p>
<ul>
<li><code>image</code>: The file path to the virtual appliance in Open Virtualization Format (OVF) or Open Virtualization Archive (OVA) which will be imported to create the virtual machines. This is explained in more detail in the <a href="http://www.virtualbox.org/manual/ch05.html#vdidetails">VirtualBox user documentation</a>.</li>
<li><code>username</code>: The login username of the guest image.</li>
<li><code>password</code>: The login password of the guest image.</li>
</ul>
<p>Example:</p>
<pre class="sourceCode"><code class="sourceCode ruby">provisioner com.ning.atlas.virtualbox.<span class="dt">VBoxProvisioner</span>, {<br />  <span class="st">:pub_key_file</span>   =&gt; <span class="st">&quot;</span><span class="ot">#{</span><span class="dt">ENV</span>[<span class="st">'HOME'</span>]<span class="ot">}</span><span class="st">/.atlas/</span><span class="ot">#{</span>rc[<span class="st">'keypair_id'</span>]<span class="ot">}</span><span class="st">.pub&quot;</span>,<br />  <span class="st">:intnet_name</span>    =&gt; <span class="st">&quot;atlas-intnet&quot;</span>,<br />  <span class="st">:bridgedif_name</span> =&gt; <span class="st">&quot;en0: Ethernet&quot;</span><br />}<br /><br />base <span class="st">&quot;server&quot;</span>, {<br />  <span class="st">:image</span> =&gt; <span class="st">&quot;</span><span class="ot">#{</span><span class="dt">ENV</span>[<span class="st">'HOME'</span>]<span class="ot">}</span><span class="st">/atlas-natty32/atlas-natty32.ovf&quot;</span>,<br />  <span class="st">:username</span> =&gt; <span class="st">&quot;atlasuser&quot;</span>,<br />  <span class="st">:password</span> =&gt; <span class="st">&quot;atlasuser&quot;</span><br />}</code></pre>
<h5 id="com.ning.atlas.statictaggedserverprovisioner"><a href="#TOC">com.ning.atlas.StaticTaggedServerProvisioner</a></h5>
<p>This provider can be used to incorporate fixed, already provisioned servers into the environment. The provider itself is used to specify the available servers, keyed by tags that can then be used in the <a href="#base-element">base element</a> to retrieve a server for initializer/installer use.</p>
<p>Eample:</p>
<pre class="sourceCode"><code class="sourceCode ruby">provisioner com.ning.atlas.<span class="dt">StaticTaggedServerProvisioner</span>, {<br />  <span class="st">:tag1</span>  =&gt; [<span class="st">&quot;server1&quot;</span>, <span class="st">&quot;server2&quot;</span>]<br />  <span class="st">:tag2</span>  =&gt; [<span class="st">&quot;server3&quot;</span>]<br />}<br /><br />base <span class="st">&quot;server&quot;</span>, {<br />  <span class="st">:tag</span> =&gt; <span class="st">&quot;tag1&quot;</span><br />}</code></pre>
<h3 id="initializers"><a href="#TOC">Initializers</a></h3>
<p>Initializers are used to configure the provisioned instances so that they can actually run services. Think of them as the part of the tool that deploys all that base software that is needed to run your software, but is not actually part of your software. Things like ruby, java, ...</p>
<p>Atlas defines these initializers at the moment: * <code>com.ning.atlas.AtlasInitializer</code> for initializing a provisioned system with Atlas-related info such as the system map. * <code>com.ning.atlas.galaxy.MicroGalaxyInitializer</code> for deploying software with <a href="https://github.com/brianm/ugalaxy">uGalaxy</a>. * <code>com.ning.atlas.chef.UbuntuChefSoloInitializer</code> for deploying software with <a href="http://wiki.opscode.com/display/chef/Chef+Solo">Chef Solo</a>.</p>
<p>Initializers are triggered via a URN in the <code>init</code> attribute of the <code>base</code> element which reference previously declared initializers. For instance given these initializer definitions:</p>
<pre class="sourceCode"><code class="sourceCode ruby">initializer <span class="st">&quot;atlas&quot;</span>, com.ning.atlas.<span class="dt">AtlasInitializer</span>, {<br />    ...<br />}<br />initializer <span class="st">&quot;chef&quot;</span>, com.ning.atlas.chef.<span class="dt">UbuntuChefSoloInitializer</span>, {<br />    ...<br />}</code></pre>
<p>this <code>base</code> element:</p>
<pre class="sourceCode"><code class="sourceCode ruby">base <span class="st">&quot;ruby-server&quot;</span>, {<br />  <span class="st">:ami</span> =&gt; <span class="st">&quot;ami-e2af508b&quot;</span>,<br />  <span class="st">:init</span> =&gt; [<span class="st">'atlas'</span>, <span class="st">'chef:role[ruby_server]'</span>]<br />}</code></pre>
<p>will trigger the two named initializers, <code>atlas</code> and <code>chef</code>. For every server that is deployed with this base system <code>ruby-server</code>, these two initializers will run in the specified order.</p>
<h5 id="com.ning.atlas.atlasinitializer"><a href="#TOC">com.ning.atlas.AtlasInitializer</a></h5>
<p>This initializer is required for proper working of Atlas because other initializers usually depend on the data it puts on the individual instances. It performs two simple functions:</p>
<ul>
<li>Upload the system map to every provisioned instance. It can then be found under <code>/etc/atlas/system_map.json</code>.</li>
<li>Upload the node info for each every provisioned instance to that instance. Can be found under <code>/etc/atlas/node_info.json</code>.</li>
</ul>
<p>The initializer needs these environment configuration options:</p>
<ul>
<li><code>ssh_user</code>: The ssh user name for the instance.</li>
<li><code>ssh_key_file</code>: The ssh private key file.</li>
</ul>
<p>Both of these depends on the how the instance is setup. For EC2 for instance, the ssh user is defined by the AMI and the private key file can be retrieved from AWS.</p>
<p>This initializer is triggered by specifying the atlas initializer's name in the <code>init</code> property of the <code>base</code> element.</p>
<p>Example:</p>
<pre class="sourceCode"><code class="sourceCode ruby">initializer <span class="st">&quot;atlas&quot;</span>, com.ning.atlas.<span class="dt">AtlasInitializer</span>, {<br />  <span class="st">:ssh_user</span>     =&gt; <span class="st">&quot;ubuntu&quot;</span>,<br />  <span class="st">:ssh_key_file</span> =&gt; <span class="st">&quot;</span><span class="ot">#{</span><span class="dt">ENV</span>[<span class="st">'HOME'</span>]<span class="ot">}</span><span class="st">/.ec2/</span><span class="ot">#{</span>ec2_keypair_id<span class="ot">}</span><span class="st">.pem&quot;</span><br />}<br />base <span class="st">&quot;ruby-server&quot;</span>, {<br />  <span class="st">:ami</span> =&gt; <span class="st">&quot;ami-e2af508b&quot;</span>,<br />  <span class="st">:init</span> =&gt; [<span class="st">'atlas'</span>, <span class="st">'chef:role[ruby_server]'</span>]<br />}</code></pre>
<h5 id="com.ning.atlas.galaxy.microgalaxyinitializer"><a href="#TOC">com.ning.atlas.galaxy.MicroGalaxyInitializer</a></h5>
<p>This initializer uses a standalone version of <a href="https://github.com/ning/galaxy">Galaxy</a> called <a href="https://github.com/brianm/ugalaxy">uGalaxy</a> to deploy software. It is basically the same as the <a href="#com.ning.atlas.galaxy.MicroGalaxyInstaller">com.ning.atlas.galaxy.MicroGalaxyInstaller</a> explained further below except that it can be run in the initializer phase and thus can be used to install software required for Galaxy or uGalaxy.</p>
<p>The initializer needs these environment configuration options:</p>
<ul>
<li><code>ssh_user</code>: The ssh user name for the instance.</li>
<li><code>ssh_key_file</code>: The ssh private key file.</li>
<li><code>ugx_user</code>: The user to run uGalaxy as.</li>
</ul>
<p>The uGalaxy initializer is triggered by using</p>
<pre><code>&lt;uGalaxy initializer name&gt;:&lt;url&gt;
</code></pre>
<p>in the <code>init</code> property of the <code>base</code> element where the url points to the tarball containing the software to deploy.</p>
<p>Example:</p>
<pre class="sourceCode"><code class="sourceCode ruby">installer <span class="st">&quot;ugx&quot;</span>, com.ning.atlas.galaxy.<span class="dt">MicroGalaxyInstaller</span>, {<br />  <span class="st">:ssh_user</span>     =&gt; <span class="st">&quot;ubuntu&quot;</span>,<br />  <span class="st">:ssh_key_file</span> =&gt; <span class="st">&quot;</span><span class="ot">#{</span><span class="dt">ENV</span>[<span class="st">'HOME'</span>]<span class="ot">}</span><span class="st">/.ec2/</span><span class="ot">#{</span>rc[<span class="st">'keypair_id'</span>]<span class="ot">}</span><span class="st">.pem&quot;</span>,<br />  <span class="st">:ugx_user</span>     =&gt; <span class="st">&quot;ugx&quot;</span><br />}<br /><br />base <span class="st">&quot;ruby-server&quot;</span>, {<br />  <span class="st">:ami</span> =&gt; <span class="st">&quot;ami-e2af508b&quot;</span>,<br />  <span class="st">:init</span> =&gt; [<span class="st">&quot;ugx:http://my-atlas-resources.s3.amazonaws.com/ruby-server.tar.gz&quot;</span>]<br />}</code></pre>
<h5 id="com.ning.atlas.chef.ubuntuchefsoloinitializer"><a href="#TOC">com.ning.atlas.chef.UbuntuChefSoloInitializer</a></h5>
<p>This initializer uses <a href="http://wiki.opscode.com/display/chef/Chef+Solo">Chef Solo</a> to put bits on the provisioned machines/instances. There are lots of tutorials on chef solo, so we won't go into detail here on what it can do and how it does things.</p>
<p>The initializer needs these environment configuration options:</p>
<ul>
<li><code>ssh_user</code>: The ssh user name for the instance (same as for the atlas initializer).</li>
<li><code>ssh_key_file</code>: The ssh private key file (same as for the atlas initializer).</li>
<li><code>recipe_url</code>: The url to the chef solo recipe bundle. For EC2, this is usually an S3 url.</li>
</ul>
<p>If the <code>recipe_url</code> is an S3 url, then the initializer also uses these two configuration values if given:</p>
<ul>
<li><code>s3_access_key</code>: The S3 access key.</li>
<li><code>s3_secret_key</code>: The S3 secret key.</li>
</ul>
<p>They can be used to access private S3 files. For that, they only need to be read-only as the initializer only uses them to download the resource from S3.</p>
<p>This initializer is triggered by using a URN of the form</p>
<pre><code>&lt;chef initializer name&gt;:&lt;spec&gt;
</code></pre>
<p>in the <code>init</code> property of the <code>base</code> element. The <code>spec</code> part can either contain a complete chef <a href="http://wiki.opscode.com/display/chef/Setting+the+run_list+in+JSON+during+run+time">run_list</a>:</p>
<pre><code>chef:{&quot;run_list&quot;:[&quot;role[base]&quot;,&quot;role[master]&quot;,&quot;recipe[nagios::server]&quot;]}
</code></pre>
<p>or a simplified form where Atlas builds the run list out of specified rols and recipes</p>
<pre><code>chef:role[base],role[master],recipe[nagios::server]
</code></pre>
<p>The initializer will then use Chef Solo to apply all recipes (found at the specified recipe url) necessary to put the machine/instance into these roles.</p>
<p>Example:</p>
<pre class="sourceCode"><code class="sourceCode ruby">initializer <span class="st">&quot;chef&quot;</span>, com.ning.atlas.chef.<span class="dt">UbuntuChefSoloInitializer</span>, {<br />  <span class="st">:ssh_user</span>     =&gt; <span class="st">&quot;ubuntu&quot;</span>,<br />  <span class="st">:ssh_key_file</span> =&gt; <span class="st">&quot;</span><span class="ot">#{</span><span class="dt">ENV</span>[<span class="st">'HOME'</span>]<span class="ot">}</span><span class="st">/.ec2/</span><span class="ot">#{</span>ec2_keypair_id<span class="ot">}</span><span class="st">.pem&quot;</span>,<br />  <span class="st">:recipe_url</span>   =&gt; <span class="st">&quot;s3://my-atlas-resources/chef-solo.tar.gz&quot;</span>,<br />  <span class="st">:s3_access_key</span> =&gt; s3_access_key,<br />  <span class="st">:s3_secret_key</span> =&gt; s3_secret_key<br />}<br /><br />base <span class="st">&quot;ruby-server&quot;</span>, {<br />  <span class="st">:ami</span> =&gt; <span class="st">&quot;ami-e2af508b&quot;</span>,<br />  <span class="st">:init</span> =&gt; [<span class="st">'atlas'</span>, <span class="st">'chef:role[ruby_server]'</span>]<br />}</code></pre>
<p>This will provision an EC2 instance (provisioner not shown) using the Ubuntu AMI ami-e2af508b, and then use Chef Solo to apply the <code>ruby-server</code> role as defined in the corresponding recipse in <code>s3://my-atlas-resources/chef-solo.tar.gz</code>.</p>
<h3 id="installers"><a href="#TOC">Installers</a></h3>
<p>Installers are what you use to deploy your services into the environment. The distinction between initializers and installers is a bit arbitrary. You can perfectly well only use initializers if you have packages that for instance can be installed with Chef Solo.</p>
<p>The main difference between initializers and installers is that installers are designed in a way that they can be run multiple times against the same machine/instance. Initializers don't require this explicitly (though depending on the initializer, they might support it).</p>
<p>You would use installers if a distinction between base packages (such as Ruby or Apache Httpd) and your service (e.g. a Rails app or some web pages served by Apache Httpd) makes sense. You can usually tell by the frequency of the updates to the component: Ruby updates tend to be rare whereas you might deploy your Rails app several times a week or even more often. In this case, you would use an installer for the rails app.</p>
<p>Installers are usually tied to a separate tool that manages deployments. Atlas currently only supports <a href="https://github.com/ning/galaxy">Galaxy</a> but adding support for other tools such as <a href="https://github.com/capistrano/capistrano/wiki/">Capistrano</a>, <a href="https://github.com/etsy/deployinator">Deployinator</a> or <a href="http://cast-project.org/">Cast</a> should be straightforward.</p>
<p>Both the environment and the system specification contain properties used by the installers. The environment specification contains the settings that allow the deployment tool to be used in the environemnt, such as SSH settings. The system specification on the other hand contains the settings that tell the deployment tool what it should actually install. Most installers simply use a URL/URN scheme in the <code>install</code> property of the <code>server</code> element (described below in the system specification).</p>
<p>Atlas also uses installers to deploy other types of services, such as load balancers (i.e. <a href="http://aws.amazon.com/elasticloadbalancing/">Amazon ELB</a> and databases. This makes it easy to initialize these services, e.g. setup a schema and data in a database or configure the load balancer for a set of services.</p>
<h5 id="com.ning.atlas.galaxy.microgalaxyinstaller"><a href="#TOC">com.ning.atlas.galaxy.MicroGalaxyInstaller</a></h5>
<p>This installer uses a standalone version of <a href="https://github.com/ning/galaxy">Galaxy</a> called <a href="https://github.com/brianm/ugalaxy">uGalaxy</a> to deploy services. It is basically the same as the <a href="#com.ning.atlas.galaxy.MicroGalaxyInitializer">com.ning.atlas.galaxy.MicroGalaxyInitializer</a> explained further above except that it is run in the installer phase.</p>
<p>The installer needs these environment configuration options:</p>
<ul>
<li><code>ssh_user</code>: The ssh user name for the instance.</li>
<li><code>ssh_key_file</code>: The ssh private key file.</li>
<li><code>ugx_user</code>: The user to run uGalaxy as.</li>
</ul>
<p>To use the uGalaxy installer, specify a URL of the form</p>
<pre><code>&lt;uGalaxy installer name&gt;:&lt;url&gt;
</code></pre>
<p>in the <code>install</code> property for the <code>server</code> element. The url points to the tarball containing the service to deploy.</p>
<p>Example:</p>
<pre class="sourceCode"><code class="sourceCode ruby">installer <span class="st">&quot;ugx&quot;</span>, com.ning.atlas.galaxy.<span class="dt">MicroGalaxyInstaller</span>, {<br />  <span class="st">:ssh_user</span>     =&gt; <span class="st">&quot;ubuntu&quot;</span>,<br />  <span class="st">:ssh_key_file</span> =&gt; <span class="st">&quot;</span><span class="ot">#{</span><span class="dt">ENV</span>[<span class="st">'HOME'</span>]<span class="ot">}</span><span class="st">/.ec2/</span><span class="ot">#{</span>ec2_keypair_id<span class="ot">}</span><span class="st">.pem&quot;</span>,<br />  <span class="st">:ugx_user</span>     =&gt; <span class="st">&quot;xncore&quot;</span><br />}</code></pre>
<pre class="sourceCode"><code class="sourceCode ruby">server <span class="st">&quot;echo&quot;</span>,<br />  <span class="st">:base</span> =&gt; <span class="st">&quot;ruby-server&quot;</span>,<br />  <span class="st">:install</span> =&gt; [<span class="st">&quot;ugx:http://my-atlas-resources.s3.amazonaws.com/echo.tar.gz&quot;</span>]</code></pre>
<h5 id="com.ning.atlas.galaxy.galaxyinstaller"><a href="#TOC">com.ning.atlas.galaxy.GalaxyInstaller</a></h5>
<p>This installer uses <a href="https://github.com/ning/galaxy">Galaxy</a>. It needs these environment configuration options:</p>
<ul>
<li><code>ssh_user</code>: The ssh user name for the instance.</li>
<li><code>ssh_key_file</code>: The ssh private key file.</li>
</ul>
<p>There are two ways to trigger the galaxy installer:</p>
<ul>
<li>Specify a galaxy role via the <code>galaxy</code> property on the <code>server</code> element.</li>
<li>Use an <code>install</code> url of the form</li>
</ul>
<pre><code>&lt;galaxy installer name&gt;:&lt;env&gt;/&lt;version&gt;/&lt;type&gt;
</code></pre>
<p>where <code>env</code> specifies the environment, <code>version</code> the version of the service, and <code>type</code> the type of the service.</p>
<p>The galaxy role form is used to deploy parts of galaxy itself. The <code>galaxy</code> property has three possible values:</p>
<ul>
<li><code>shell</code>: A generic shell server including the galaxy commandline tool.</li>
<li><code>console</code>: The galaxy console.</li>
<li><code>repository</code>: The file repository containing the deployable artifacts.</li>
</ul>
<p>The <code>console</code> and <code>repository</code> are required or galaxy won't be able to deploy anything else. A shell is not strictly required but useful if you want to interact with galaxy manually.</p>
<p>Example:</p>
<pre class="sourceCode"><code class="sourceCode ruby">installer <span class="st">&quot;galaxy&quot;</span>, com.ning.atlas.galaxy.<span class="dt">GalaxyInstaller</span>, {<br />  <span class="st">:ssh_user</span>     =&gt; <span class="st">&quot;ubuntu&quot;</span>,<br />  <span class="st">:ssh_key_file</span> =&gt; <span class="st">&quot;</span><span class="ot">#{</span><span class="dt">ENV</span>[<span class="st">'HOME'</span>]<span class="ot">}</span><span class="st">/.ec2/</span><span class="ot">#{</span>ec2_keypair_id<span class="ot">}</span><span class="st">.pem&quot;</span>,<br />}</code></pre>
<pre class="sourceCode"><code class="sourceCode ruby">server <span class="st">&quot;echo&quot;</span>,<br />  <span class="st">:base</span> =&gt; <span class="st">&quot;ruby-server&quot;</span>,<br />  <span class="st">:install</span> =&gt; [<span class="st">&quot;galaxy:myenv/v1/echo&quot;</span>]</code></pre>
<h5 id="com.ning.atlas.oracle.oracleloaderinstaller"><a href="#TOC">com.ning.atlas.oracle.OracleLoaderInstaller</a></h5>
<p>The Oracle installer provides a way to initialize the schema and data in an Amazon RDS Oracle database instance by passing specified text files containing DDL/DML statements to Oracle's <a href="http://download.oracle.com/docs/cd/B28359_01/server.111/b31189/toc.htm">SQL*Plus</a>.</p>
<p>It needs these environment configuration options:</p>
<ul>
<li><code>ssh_user</code>: The ssh user name for the instance.</li>
<li><code>ssh_key_file</code>: The ssh private key file.</li>
<li><code>sql_url_template</code>: This is a <a href="http://www.stringtemplate.org/">StringTemplate</a> to generate the S3 urls for the schema files. This is explained further below.</li>
</ul>
<p>The installer is triggered by using an URN of the form</p>
<pre><code>&lt;oracle installer name&gt;:&lt;data&gt;
</code></pre>
<p>in the <code>install</code> property for the <code>server</code> element. The data part of the URN contains key value pairs of the form</p>
<pre><code>&lt;oracle installer name&gt;:key1=value1;key2=value2;...
</code></pre>
<p>These keys can then be referenced in the url template. E.g. typically you template the file name like so:</p>
<pre class="sourceCode"><code class="sourceCode ruby">installer <span class="st">&quot;oracle&quot;</span>, com.ning.atlas.oracle.<span class="dt">OracleLoaderInstaller</span>, {<br />  <span class="st">:sql_url_template</span> =&gt; <span class="st">&quot;s3://my-atlas-resources/$file$&quot;</span>,<br />  <span class="st">:ssh_user</span>     =&gt; <span class="st">&quot;ubuntu&quot;</span>,<br />  <span class="st">:ssh_key_file</span> =&gt; <span class="st">&quot;</span><span class="ot">#{</span><span class="dt">ENV</span>[<span class="st">'HOME'</span>]<span class="ot">}</span><span class="st">/.ec2/</span><span class="ot">#{</span>rc[<span class="st">'keypair_id'</span>]<span class="ot">}</span><span class="st">.pem&quot;</span><br />}</code></pre>
<pre class="sourceCode"><code class="sourceCode ruby">server <span class="st">&quot;userdb&quot;</span>,<br />  <span class="st">:base</span> =&gt; <span class="st">&quot;oracle&quot;</span>,<br />  <span class="st">:install</span> =&gt; [<span class="st">&quot;oracle:file=userdb-ddl.sql&quot;</span>],<br />  <span class="st">:db_role</span> =&gt; [<span class="st">'user'</span>]</code></pre>
<p>This will make the oracle installer look for a file <code>s3://my-atlas-resources/userdb-ddl.sql</code> when initializing a server <code>userdb</code>.</p>
<h5 id="com.ning.atlas.aws.elbinstaller"><a href="#TOC">com.ning.atlas.aws.ELBInstaller</a></h5>
<p>This installer allows to register servers with Amazon's <a href="https://aws.amazon.com/elasticloadbalancing/">Elastic Load Balancer</a>.</p>
<p>For this, it needs these environment configuration options:</p>
<ul>
<li><code>access_key</code>: The EC2 access key.</li>
<li><code>secret_key</code>: The EC2 secret key.</li>
</ul>
<p>The installer is triggered by specifying the name of the installer in the <code>install</code> property for the <code>server</code> element.</p>
<p>Example:</p>
<pre class="sourceCode"><code class="sourceCode ruby">installer <span class="st">&quot;ugx&quot;</span>, com.ning.atlas.galaxy.<span class="dt">MicroGalaxyInstaller</span>, {<br />    ...<br />}<br /><br />installer <span class="st">&quot;elb&quot;</span>, com.ning.atlas.aws.<span class="dt">ELBInstaller</span>, {<br />  <span class="st">:access_key</span> =&gt; rc[<span class="st">'access_key'</span>],<br />  <span class="st">:secret_key</span> =&gt; rc[<span class="st">'secret_key'</span>]<br />}</code></pre>
<pre class="sourceCode"><code class="sourceCode ruby">server <span class="st">&quot;echo&quot;</span>,<br />  <span class="st">:base</span> =&gt; <span class="st">&quot;ruby-server&quot;</span>,<br />  <span class="st">:install</span> =&gt; [<span class="st">&quot;ugx:http://my-atlas-resources.s3.amazonaws.com/echo.tar.gz&quot;</span>, <span class="st">&quot;elb&quot;</span>]</code></pre>
<h2 id="system-specification"><a href="#TOC">System specification</a></h2>
<h1 id="running"><a href="#TOC">Running</a></h1>
<p>Invoking atlas without any arguments will show the basic help</p>
<pre><code>$ atlas

Missing one or both of environment or system specification paths
Option                                  Description
------                                  -----------
-e, --env, --environment                Environment specification file
-s, --sys, --system                     System specification file
</code></pre>
<p>Atlas only needs two arguments on the command line: the path to the <a href="#environment-specification">environment specification</a> and the path to the <a href="#system-specification">system specification</a>. Everything else is configured within those two files.</p>
<p>When running against EC2, you should also make sure that before invoking atlas, the ssh key is registered, e.g.:</p>
<pre><code>$ ssh-add my-ec2-keypair.pem
</code></pre>
<h1 id="output"><a href="#TOC">Output</a></h1>
<p>TBD</p>
<h1 id="resources"><a href="#TOC">Resources</a></h1>
<h2 id="virtualbox"><a href="#TOC">VirtualBox</a></h2>
<p>To use the VirtualBox provisioner, a VirtualBox image is required. Typically, such an image can be created using VirtualBox or VMWare, and the appliance is then exported to an <a href="http://en.wikipedia.org/wiki/Open_Virtualization_Format">Open Virtualization Format</a> (OVF) file with the hard disk separate, or an Open Virtualization Archive (OVA) which is a zipped copy of the hard disk and the OVF file.</p>
<p>Because creating a VirtualBox image can be a hassel, we have written a simple script <a href="https://github.com/ning/atlas/blob/master/src/main/resources/vbox/createvm.sh">createvm.sh</a> that automates the creation of the bare virtual hardware. Note that because the Linux kernel in Ubuntu Server is compiled with PAE, you need enable PAE support on the VM if you are running Ubuntu Server.</p>
<p>We have also provided a <a href="https://github.com/ning/atlas/blob/master/src/main/resources/vbox/postinstall_atlas.sh">postinstall_atlas.sh</a> script that can be run after installing the guest OS on the virtual machine. The script also installs the required VirtualBox Guest Additions.</p>
<p>Currently, we have provided the following images to help you get started:</p>
<ul>
<li><a href="https://atlas-resources.s3.amazonaws.com/atlas-natty32.ova">Ubuntu Server 11.04 Natty 32</a></li>
<li><a href="https://atlas-resources.s3.amazonaws.com/atlas-natty64.ova">Ubuntu Server 11.04 Natty 64</a></li>
</ul>
<p>They have the following specifications:</p>
<ul>
<li>Default username/password: atlasuser/atlasuser</li>
<li>Base Memory: 384 MB</li>
<li>80 GB HDD</li>
<li>Uses VT-x, PAE/NX</li>
<li>NIC 1: Bridged Adapter</li>
<li>NIC 2: Internal Network Adapter</li>
</ul>
<h2 id="getting-help"><a href="#TOC">Getting Help</a></h2>
<p>We have a <a href="http://groups.google.com/group/atlas-dev">development mailing list</a>.</p>
</body>
</html>
